<?php
declare( strict_types=1 );

namespace WMDE\Fundraising\PaymentContext\Services\PayPal\Model;

use UnexpectedValueException;
use WMDE\Fundraising\PaymentContext\Domain\Model\PaymentInterval;

class SubscriptionPlan {

	/**
	 * @param string $name
	 * @param string $productId
	 * @param PaymentInterval $monthlyInterval
	 * @param string|null $id gets generated by the PayPal API
	 * @param string|null $description
	 */
	public function __construct(
		public readonly string $name,
		public readonly string $productId,
		public readonly PaymentInterval $monthlyInterval,
		public readonly ?string $id = null,
		public readonly ?string $description = null
	) {
		if ( trim( $this->name ) === '' ) {
			throw new \UnexpectedValueException( 'Subscription plan name must not be empty' );
		}
	}

	/**
	 * @param array<string,mixed> $apiReponse A single plan item from the PayPal API response
	 * @return SubscriptionPlan
	 */
	public static function from( array $apiReponse ): SubscriptionPlan {
		// Theoretically, we'd want to check name, product_id, and id in $apiData,
		// but the billing_cycles check should be sufficient to detect broken data from the PayPal API

		if ( empty( $apiReponse['billing_cycles'] ) || !is_array( $apiReponse['billing_cycles'] ) || count( $apiReponse['billing_cycles'] ) !== 1 ) {
			throw new PayPalAPIException( 'Wrong billing cycle data' );
		}
		$billingCycle = $apiReponse['billing_cycles'][0];

		if ( !isset( $billingCycle['frequency'] ) || !isset( $billingCycle['frequency']['interval_count'] ) ) {
			throw new PayPalAPIException( 'Wrong frequency data in billing cycle' );
		}
		$frequency = $billingCycle['frequency'];

		if ( ( $frequency['interval_unit'] ?? '' ) !== 'MONTH' ) {
			throw new PayPalAPIException( 'interval_unit must be MONTH' );
		}
		$monthlyInterval = PaymentInterval::from( intval( $frequency['interval_count'] ) );
		$description = $apiReponse['description'] ?? '';

		// Make static typechecker happy, using strval on mixed throws errors
		if (
			!is_scalar( $apiReponse['name'] ) ||
			!is_scalar( $apiReponse['product_id'] ) ||
			!is_scalar( $apiReponse['id'] ) ||
			!is_scalar( $description )
		) {
			throw new UnexpectedValueException( 'Scalar value expected' );
		}

		return new SubscriptionPlan(
			strval( $apiReponse['name'] ),
			strval( $apiReponse['product_id'] ),
			$monthlyInterval,
			strval( $apiReponse['id'] ),
			strval( $description ),
		);
	}

	/**
	 * @phpstan-ignore-next-line
	 */
	public static function getBillingCycle( int $monthlyInterval, string $amount ): array {
		return [ [
			"sequence" => 1,
			"pricing_scheme" => [
				"fixed_price" => [
					"value" => $amount,
					"currency_code" => "EUR"
				]
			],
			"tenure_type" => "REGULAR",
			"frequency" => [
				"interval_unit" => "MONTH",
				"interval_count" => $monthlyInterval
			],
			"total_cycles" => 0
		] ];
	}

	public function toJSON(): string {
		return json_encode( [
			"name" => $this->name,
			"product_id" => $this->productId,
			"description" => $this->description,
			// pricing_scheme with amount is required by the api, but value is set to 1 EUR
			// subscriptions must override this with the actual value of the donation/membership fee
			"billing_cycles" => self::getBillingCycle( $this->monthlyInterval->value, "1" ),
			"payment_preferences" => [
				"auto_bill_outstanding" => true,
				"setup_fee_failure_action" => "CONTINUE",
				"payment_failure_threshold" => 0,
				"setup_fee" => [
					"currency_code" => "EUR",
					"value" => "0"
				]
			]
		], JSON_THROW_ON_ERROR );
	}

}
